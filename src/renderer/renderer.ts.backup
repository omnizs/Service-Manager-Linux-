import type { ServiceAction, ServiceInfo, ServiceListFilters } from '../types/service';

type ToastType = 'info' | 'success' | 'error';

interface AppState {
  services: ServiceInfo[];
  filtered: ServiceInfo[];
  selectedId: string | null;
  loading: boolean;
  pollInterval: number;
  pollTimer: ReturnType<typeof setInterval> | null;
  lastUpdated: Date | null;
  currentPage: number;
  itemsPerPage: number;
  isRefreshing: boolean;
  isWindowFocused: boolean;
  virtualScrollEnabled: boolean;
  scrollTop: number;
  rowHeight: number;
  visibleRows: number;
}

interface DetailAction {
  label?: string;
  handler: () => void;
}

type AppendDetailOptions =
  | string
  | {
      valueClass?: string;
      action?: DetailAction | null;
    }
  | undefined;

interface DomRefs {
  tableBody: HTMLTableSectionElement;
  searchInput: HTMLInputElement;
  statusFilter: HTMLSelectElement;
  lastUpdated: HTMLElement;
  serviceCount: HTMLElement;
  detailsPane: HTMLElement;
  refreshButton: HTMLButtonElement;
  statusText: HTMLElement;
  indicatorDot: HTMLElement;
  toastContainer: HTMLElement;
  platformInfo: HTMLElement;
  performanceInfo: HTMLElement;
  tableContainer: HTMLElement;
}

const state: AppState = {
  services: [],
  filtered: [],
  selectedId: null,
  loading: false,
  pollInterval: 5000,
  pollTimer: null,
  lastUpdated: null,
  currentPage: 1,
  itemsPerPage: 100,
  isRefreshing: false,
  isWindowFocused: true,
  virtualScrollEnabled: false,
  scrollTop: 0,
  rowHeight: 49, // Average row height in pixels
  visibleRows: 20, // Number of rows visible in viewport
};

const dom = {} as DomRefs;

document.addEventListener('DOMContentLoaded', () => {
  cacheDom();
  bindEvents();
  bindKeyboardShortcuts();
  bindWindowEvents();
  void refreshServices({ showLoader: true });
  startPolling();
});

function cacheDom(): void {
  dom.tableBody = getElement<HTMLTableSectionElement>('servicesTableBody');
  dom.searchInput = getElement<HTMLInputElement>('searchInput');
  dom.statusFilter = getElement<HTMLSelectElement>('statusFilter');
  dom.lastUpdated = getElement<HTMLElement>('lastUpdated');
  dom.serviceCount = getElement<HTMLElement>('serviceCount');
  dom.detailsPane = getElement<HTMLElement>('detailsPane');
  dom.refreshButton = getElement<HTMLButtonElement>('refreshButton');
  dom.statusText = getElement<HTMLElement>('statusText');
  dom.indicatorDot = getElement<HTMLElement>('indicatorDot');
  dom.toastContainer = getElement<HTMLElement>('toastContainer');
  dom.platformInfo = getElement<HTMLElement>('platformInfo');
  dom.performanceInfo = getElement<HTMLElement>('performanceInfo');
  
  const tableContainer = document.querySelector('.table-container');
  if (tableContainer) {
    dom.tableContainer = tableContainer as HTMLElement;
    dom.tableContainer.addEventListener('scroll', onTableScroll);
  }
  
  const platform = navigator.platform || 'Unknown';
  const os = platform.includes('Win') ? 'Windows' : platform.includes('Mac') ? 'macOS' : 'Linux';
  dom.platformInfo.textContent = os;
}

function getElement<T extends HTMLElement>(id: string): T {
  const el = document.getElementById(id);
  if (!el) {
    throw new Error(`Missing required element #${id}`);
  }
  return el as T;
}

function bindEvents(): void {
  const debouncedFilter = debounce(applyFilters, 120); // Reduced to 120ms for snappier UI
  dom.searchInput.addEventListener('input', debouncedFilter);
  dom.statusFilter.addEventListener('change', applyFilters);
  dom.refreshButton.addEventListener('click', () => void refreshServices({ showLoader: true }));
}

function bindKeyboardShortcuts(): void {
  document.addEventListener('keydown', (event) => {
    if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
      event.preventDefault();
      void refreshServices({ showLoader: true });
    }
    
    if (event.key === 'Escape' && state.selectedId) {
      event.preventDefault();
      state.selectedId = null;
      renderTable();
      renderDetails(null);
    }
    
    if ((event.ctrlKey || event.metaKey) && event.key === 'f') {
      event.preventDefault();
      dom.searchInput.focus();
      dom.searchInput.select();
    }
  });
}

function bindWindowEvents(): void {
  window.addEventListener('focus', () => {
    state.isWindowFocused = true;
    startPolling();
  });

  window.addEventListener('blur', () => {
    state.isWindowFocused = false;
  });

  window.addEventListener('beforeunload', () => {
    stopPolling();
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      state.isWindowFocused = false;
    } else {
      state.isWindowFocused = true;
      void refreshServices({ showLoader: false });
    }
  });
}

function startPolling(): void {
  stopPolling();
  const getPollingInterval = () => {
    return state.isWindowFocused && !document.hidden ? state.pollInterval : state.pollInterval * 3;
  };
  
  const poll = () => {
    if (state.isWindowFocused && !document.hidden) {
      void refreshServices({ showLoader: false });
    }
    state.pollTimer = setTimeout(poll, getPollingInterval());
  };
  
  state.pollTimer = setTimeout(poll, getPollingInterval());
}

function stopPolling(): void {
  if (state.pollTimer) {
    clearTimeout(state.pollTimer);
    state.pollTimer = null;
  }
}

async function refreshServices({ showLoader }: { showLoader: boolean }): Promise<void> {
  if (state.loading || state.isRefreshing) return;

  state.isRefreshing = true;
  const startTime = performance.now();
  setLoading(true, showLoader);
  try {
    const response = await window.serviceAPI.listServices({
      search: dom.searchInput.value.trim() || undefined,
      status: dom.statusFilter.value,
    } satisfies ServiceListFilters);

    if (!response || !response.ok) {
      const message = response?.error?.message ?? 'Failed to load services';
      throw new Error(message);
    }

    state.services = Array.isArray(response.data) ? response.data : [];
    state.lastUpdated = new Date();
    
    const endTime = performance.now();
    const loadTime = Math.round(endTime - startTime);
    dom.performanceInfo.textContent = `Loaded in ${loadTime}ms`;
    
    applyFilters();
  } catch (error) {
    console.error('Failed to refresh services', error);
    const friendlyMessage = getUserFriendlyErrorMessage(error, 'load services');
    showToast(friendlyMessage, 'error');
    dom.performanceInfo.textContent = 'Load failed';
  } finally {
    setLoading(false, showLoader);
    state.isRefreshing = false;
  }
}


function onTableScroll(): void {
  if (!state.virtualScrollEnabled) return;
  
  state.scrollTop = dom.tableContainer.scrollTop;
  
  requestAnimationFrame(() => {
    renderTable();
  });
}


function calculateVisibleRange(): { start: number; end: number; offsetY: number } {
  if (!state.virtualScrollEnabled) {
    return { start: 0, end: state.filtered.length, offsetY: 0 };
  }

  const scrollTop = state.scrollTop;
  const startIndex = Math.floor(scrollTop / state.rowHeight);
  const endIndex = Math.min(
    startIndex + state.visibleRows + 5, // Add buffer rows
    state.filtered.length
  );
  
  return {
    start: Math.max(0, startIndex - 2), // Add buffer before
    end: endIndex,
    offsetY: Math.max(0, startIndex - 2) * state.rowHeight
  };
}

function applyFilters(): void {
  const search = dom.searchInput.value.trim().toLowerCase();
  const status = dom.statusFilter.value;

  let filtered = state.services.slice();

  if (search) {
    filtered = filtered.filter((item) =>
      item.name.toLowerCase().includes(search) ||
      (item.description && item.description.toLowerCase().includes(search)) ||
      (item.executable && item.executable.toLowerCase().includes(search))
    );
  }

  if (status && status !== 'all') {
    const target = status.toLowerCase();
    filtered = filtered.filter((item) => (item.status || '').toLowerCase() === target);
  }

  state.filtered = filtered;
  
  state.virtualScrollEnabled = filtered.length >= 500;
  
  state.currentPage = 1; // Reset to first page when filters change
  state.scrollTop = 0; // Reset scroll position
  if (dom.tableContainer) {
    dom.tableContainer.scrollTop = 0;
  }
  
  renderTable();
  updateFooter();

  if (state.selectedId) {
    const current = state.filtered.find((item) => item.id === state.selectedId) ?? null;
    if (!current) {
      state.selectedId = null;
      renderDetails(null);
    } else {
      renderDetails(current);
    }
  }
}

function renderTable(): void {
  const fragment = document.createDocumentFragment();

  if (!state.filtered.length) {
    const row = document.createElement('tr');
    row.className = 'empty';
    const cell = document.createElement('td');
    cell.colSpan = 6;
    cell.textContent = 'No services found matching the current filters';
    row.appendChild(cell);
    fragment.appendChild(row);
    dom.tableBody.innerHTML = '';
    dom.tableBody.appendChild(fragment);
    return;
  }

  let pageItems: ServiceInfo[];
  let startIndex: number;
  let endIndex: number;
  let totalPages = 1; // Initialize to avoid TypeScript errors

  if (state.virtualScrollEnabled) {
    const range = calculateVisibleRange();
    startIndex = range.start;
    endIndex = range.end;
    pageItems = state.filtered.slice(startIndex, endIndex);
    
    if (range.offsetY > 0) {
      const spacerBefore = document.createElement('tr');
      spacerBefore.style.height = `${range.offsetY}px`;
      spacerBefore.className = 'virtual-spacer';
      const spacerCell = document.createElement('td');
      spacerCell.colSpan = 6;
      spacerBefore.appendChild(spacerCell);
      fragment.appendChild(spacerBefore);
    }
  } else {
    totalPages = Math.ceil(state.filtered.length / state.itemsPerPage);
    startIndex = (state.currentPage - 1) * state.itemsPerPage;
    endIndex = Math.min(startIndex + state.itemsPerPage, state.filtered.length);
    pageItems = state.filtered.slice(startIndex, endIndex);
  }

  pageItems.forEach((service, index) => {
    const row = document.createElement('tr');
    row.dataset.serviceId = service.id;
    row.dataset.index = String(startIndex + index);
    
    if (state.selectedId === service.id) {
      row.classList.add('selected');
    }

    row.addEventListener('click', () => void selectService(service));

    row.appendChild(createCell(service.name, 'cell-name', false, service.name));
    row.appendChild(createStatusCell(service));
    row.appendChild(createCell(formatStartupType(service.startupType), 'cell-startup', false, formatStartupType(service.startupType)));
    row.appendChild(createCell(service.executable || '‚Äî', 'cell-executable', true, service.executable || ''));
    row.appendChild(createCell(service.description || '‚Äî', 'cell-description', false, service.description || ''));
    row.appendChild(createActionsCell(service));

    fragment.appendChild(row);
  });

  if (state.virtualScrollEnabled) {
    const range = calculateVisibleRange();
    const remainingHeight = (state.filtered.length - range.end) * state.rowHeight;
    if (remainingHeight > 0) {
      const spacerAfter = document.createElement('tr');
      spacerAfter.style.height = `${remainingHeight}px`;
      spacerAfter.className = 'virtual-spacer';
      const spacerCell = document.createElement('td');
      spacerCell.colSpan = 6;
      spacerAfter.appendChild(spacerCell);
      fragment.appendChild(spacerAfter);
    }
  }

  dom.tableBody.innerHTML = '';
  dom.tableBody.appendChild(fragment);

  if (!state.virtualScrollEnabled && totalPages > 1) {
    const paginationRow = document.createElement('tr');
    paginationRow.className = 'pagination-row';
    const paginationCell = document.createElement('td');
    paginationCell.colSpan = 6;
    paginationCell.className = 'pagination-cell';
    
    const paginationInfo = document.createElement('div');
    paginationInfo.className = 'pagination-info';
    paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${state.filtered.length}`;
    
    const paginationControls = document.createElement('div');
    paginationControls.className = 'pagination-controls';
    
    const prevBtn = document.createElement('button');
    prevBtn.textContent = '‚Üê Previous';
    prevBtn.className = 'pagination-button';
    prevBtn.disabled = state.currentPage === 1;
    prevBtn.addEventListener('click', () => {
      if (state.currentPage > 1) {
        state.currentPage--;
        renderTable();
        updateFooter();
      }
    });
    
    const pageInfo = document.createElement('span');
    pageInfo.className = 'page-info';
    pageInfo.textContent = `Page ${state.currentPage} of ${totalPages}`;
    
    const nextBtn = document.createElement('button');
    nextBtn.textContent = 'Next ‚Üí';
    nextBtn.className = 'pagination-button';
    nextBtn.disabled = state.currentPage === totalPages;
    nextBtn.addEventListener('click', () => {
      if (state.currentPage < totalPages) {
        state.currentPage++;
        renderTable();
        updateFooter();
      }
    });
    
    paginationControls.appendChild(prevBtn);
    paginationControls.appendChild(pageInfo);
    paginationControls.appendChild(nextBtn);
    
    paginationCell.appendChild(paginationInfo);
    paginationCell.appendChild(paginationControls);
    paginationRow.appendChild(paginationCell);
    dom.tableBody.appendChild(paginationRow);
  }
}

function createCell(content: string, className = '', monospace = false, tooltip = ''): HTMLTableCellElement {
  const cell = document.createElement('td');
  if (className) cell.className = className;
  
  if (tooltip && tooltip !== '‚Äî') {
    cell.title = tooltip;
  }
  
  if (monospace) {
    const span = document.createElement('span');
    span.className = 'monospace';
    span.textContent = content;
    cell.appendChild(span);
  } else {
    cell.textContent = content;
  }
  return cell;
}

function createStatusCell(service: ServiceInfo): HTMLTableCellElement {
  const cell = document.createElement('td');
  cell.className = 'cell-status';

  const normalizedStatus = normalizeStatus(service.status);
  const badge = document.createElement('span');
  badge.className = `status-badge status-${normalizedStatus}`;
  badge.textContent = formatStatusLabel(service.statusLabel || service.status || 'unknown');
  cell.appendChild(badge);

  return cell;
}

function normalizeStatus(status: string | undefined): string {
  if (!status) return 'unknown';
  const lower = status.toLowerCase();
  
  if (lower.includes('inactive') || lower.includes('dead') || lower.includes('stopped')) return 'inactive';
  if (lower.includes('active') || lower.includes('running')) return 'active';
  if (lower.includes('failed')) return 'failed';
  if (lower.includes('activating')) return 'activating';
  if (lower.includes('deactivating')) return 'deactivating';
  
  return lower;
}

function formatStatusLabel(label: string): string {
  if (!label) return 'Unknown';
  
  const cleaned = label.replace(/\s*\([^)]*\)/g, '').trim();
  
  return cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();
}

function createActionsCell(service: ServiceInfo): HTMLTableCellElement {
  const cell = document.createElement('td');
  cell.className = 'cell-actions';

  const startBtn = createActionButton('Start', 'start', service.canStart);
  const stopBtn = createActionButton('Stop', 'stop', service.canStop);
  const restartBtn = createActionButton('Restart', 'restart', service.canRestart);
  const enableBtn = createActionButton('Enable', 'enable', service.canEnable);
  const disableBtn = createActionButton('Disable', 'disable', service.canDisable);

  startBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    void handleAction('start', service);
  });

  stopBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    void handleAction('stop', service);
  });

  restartBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    void handleAction('restart', service);
  });

  enableBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    void handleAction('enable', service);
  });

  disableBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    void handleAction('disable', service);
  });

  cell.appendChild(startBtn);
  cell.appendChild(stopBtn);
  cell.appendChild(restartBtn);
  cell.appendChild(enableBtn);
  cell.appendChild(disableBtn);

  return cell;
}

function createActionButton(label: string, action: ServiceAction, enabled: boolean): HTMLButtonElement {
  const button = document.createElement('button');
  button.type = 'button';
  button.className = `action-button action-${action}`;
  button.textContent = label;
  button.disabled = !enabled;
  return button;
}

async function selectService(service: ServiceInfo): Promise<void> {
  state.selectedId = service.id;
  renderTable();
  renderDetails(service);

  try {
    const response = await window.serviceAPI.getServiceDetails(service.id);
    if (response && response.ok && response.data) {
      const updatedService: ServiceInfo = {
        ...service,
        ...response.data,
      };
      renderDetails(updatedService);
    }
  } catch (error) {
    console.warn('Failed to load service details', error);
  }
}

function renderDetails(service: ServiceInfo | null): void {
  dom.detailsPane.innerHTML = '';

  if (!service) {
    const emptyState = document.createElement('div');
    emptyState.className = 'empty-state';
    emptyState.innerHTML = `
      <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M24 4C12.96 4 4 12.96 4 24C4 35.04 12.96 44 24 44C35.04 44 44 35.04 44 24C44 12.96 35.04 4 24 4ZM24 40C15.18 40 8 32.82 8 24C8 15.18 15.18 8 24 8C32.82 8 40 15.18 40 24C40 32.82 32.82 40 24 40ZM22 22V14H26V22H22ZM22 34V26H26V34H22Z" fill="currentColor" opacity="0.3"/>
      </svg>
      <p>Select a service to view details</p>
    `;
    dom.detailsPane.appendChild(emptyState);
    return;
  }

  const list = document.createElement('dl');

  appendDetail(list, 'Name', service.name || service.id);
  appendDetail(list, 'Identifier', service.id);
  appendDetail(list, 'Status', formatStatusLabel(service.statusLabel || service.status || 'unknown'));
  appendDetail(list, 'Startup Type', formatStartupType(service.startupType));
  appendDetail(list, 'Executable', service.executable || '‚Äî', service.executable ? 'monospace' : '');
  appendDetail(list, 'PID', service.pid ? String(service.pid) : '‚Äî');
  appendDetail(list, 'Description', service.description || '‚Äî');

  appendDetail(
    list,
    'Unit File',
    service.unitFile || '‚Äî',
    service.unitFile
      ? {
          valueClass: 'monospace',
          action: {
            label: 'Show in File Browser',
            handler: () => window.serviceAPI.openPath(service.unitFile as string),
          },
        }
      : undefined
  );

  dom.detailsPane.appendChild(list);
}

function appendDetail(list: HTMLDListElement, label: string, value: string, options?: AppendDetailOptions): void {
  let valueClass = '';
  let action: DetailAction | null = null;

  if (typeof options === 'string') {
    valueClass = options;
  } else if (options && typeof options === 'object') {
    valueClass = options.valueClass || '';
    action = options.action || null;
  }

  const dt = document.createElement('dt');
  dt.textContent = label;
  const dd = document.createElement('dd');
  const valueNode = document.createElement('span');
  if (valueClass) valueNode.className = valueClass;
  valueNode.textContent = value;

  if (action && typeof action.handler === 'function') {
    const wrapper = document.createElement('div');
    wrapper.className = 'detail-value-with-action';
    wrapper.appendChild(valueNode);

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'inline-button';
    button.textContent = action.label || 'Open';
    button.addEventListener('click', action.handler);

    wrapper.appendChild(button);
    dd.appendChild(wrapper);
  } else {
    dd.appendChild(valueNode);
  }

  list.appendChild(dt);
  list.appendChild(dd);
}

function updateFooter(): void {
  const count = state.filtered.length;
  dom.serviceCount.textContent = `${count} ${count === 1 ? 'service' : 'services'}`;
  dom.lastUpdated.textContent = state.lastUpdated
    ? `Last updated: ${state.lastUpdated.toLocaleTimeString()}`
    : 'Last updated: ‚Äî';
}

function setLoading(isLoading: boolean, showIndicator: boolean): void {
  state.loading = isLoading;
  if (!showIndicator) return;

  if (isLoading) {
    dom.statusText.textContent = 'Refreshing‚Ä¶';
    dom.indicatorDot.classList.add('active');
  } else {
    dom.statusText.textContent = 'Idle';
    dom.indicatorDot.classList.remove('active');
  }
}

async function handleAction(action: ServiceAction, service: ServiceInfo): Promise<void> {
  try {
    const response = await window.serviceAPI.controlService(service.id, action);
    if (!response || !response.ok) {
      const message = response?.error?.message ?? 'Action failed';
      throw new Error(message);
    }
    showToast(`‚úì ${capitalize(action)} requested for ${service.name}`, 'success');
    await refreshServices({ showLoader: false });
  } catch (error) {
    console.error(`Failed to ${action} service`, error);
    const friendlyMessage = getUserFriendlyErrorMessage(error, `${action} ${service.name}`);
    showToast(friendlyMessage, 'error');
  }
}


function getUserFriendlyErrorMessage(error: unknown, context: string): string {
  if (!(error instanceof Error)) {
    return `Unable to ${context}. Please try again.`;
  }

  const message = error.message.toLowerCase();
  
  if (message.includes('permission') || message.includes('access denied') || message.includes('forbidden') || message.includes('eacces')) {
    return `‚ö†Ô∏è Permission denied. You may need administrator privileges to ${context}.`;
  }
  
  if (message.includes('timeout') || message.includes('timed out')) {
    return `‚è±Ô∏è Operation timed out while trying to ${context}. The service may be unresponsive.`;
  }
  
  if (message.includes('not found') || message.includes('does not exist') || message.includes('enoent')) {
    return `üîç Service not found. It may have been removed or ${context} is unavailable.`;
  }
  
  if (message.includes('already running') || message.includes('already active')) {
    return `‚ÑπÔ∏è Service is already running. No action needed.`;
  }
  
  if (message.includes('already stopped') || message.includes('not running')) {
    return `‚ÑπÔ∏è Service is already stopped. No action needed.`;
  }
  
  if (message.includes('failed to start')) {
    return `‚ùå Failed to start service. Check service configuration and logs for details.`;
  }
  
  if (message.includes('connection') || message.includes('network')) {
    return `üåê Connection error while trying to ${context}. Check your network connection.`;
  }
  
  if (message.includes('rate limit') || message.includes('too many requests')) {
    return `‚è∏Ô∏è Too many requests. Please wait a moment before trying to ${context} again.`;
  }
  
  if (error.message.length < 100) {
    return `‚ùå Failed to ${context}: ${error.message}`;
  }
  
  return `‚ùå Failed to ${context}. Check the console for details.`;
}

function formatStartupType(value: string | undefined): string {
  if (!value) return 'Unknown';
  return value.charAt(0).toUpperCase() + value.slice(1);
}

function debounce<T extends (...args: never[]) => void>(fn: T, wait: number): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;
  return (...args: Parameters<T>) => {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => fn(...args), wait);
  };
}

function cleanup(): void {
  stopPolling();
  state.pollTimer = null;
}

function capitalize(value: string): string {
  if (!value) return value;
  return value.charAt(0).toUpperCase() + value.slice(1);
}

function showToast(message: string, type: ToastType = 'info'): void {
  if (!dom.toastContainer) return;

  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.textContent = message;

  dom.toastContainer.appendChild(toast);

  requestAnimationFrame(() => {
    toast.classList.add('visible');
  });

  setTimeout(() => {
    toast.classList.remove('visible');
    setTimeout(() => {
      toast.remove();
    }, 300);
  }, 3200);
}
